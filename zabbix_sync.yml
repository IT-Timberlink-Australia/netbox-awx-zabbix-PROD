---
# =============================================================================
# NetBox to Zabbix Host Synchronization Playbook
# =============================================================================
# Description: Synchronizes NetBox device/VM inventory into Zabbix monitoring
#              system with bidirectional status tracking via custom fields.
#
# Author: Infrastructure Team
# Version: 2.0
# Last Updated: 2024
#
# Requirements:
#   - Ansible 2.9+
#   - netbox.netbox collection
#   - Zabbix API access with appropriate permissions
#   - NetBox API access with custom field write permissions
#
# Environment Variables Required:
#   - ZABBIX_API_URL: Zabbix API endpoint (e.g., https://zabbix.example.com/api_jsonrpc.php)
#   - ZABBIX_API_TOKEN: Zabbix API authentication token
#   - ZABBIX_VERIFY: SSL certificate verification (default: false)
#   - NETBOX_API: NetBox API endpoint (e.g., https://netbox.example.com/api)
#   - NETBOX_TOKEN: NetBox API authentication token
#   - NETBOX_VERIFY: SSL certificate verification (default: true)
#
# NetBox Custom Fields Required:
#   - zbp_vname: Visible name in Zabbix (optional, defaults to hostname)
#   - zbp_pri_template_name_id: Primary Zabbix template ID
#   - zb_extra_templates: Additional template IDs (list)
#   - zbp_pri_template_int_id: Interface type (1=Agent, 2=SNMP, 3=IPMI, 4=JMX)
#   - zbp_int_ip: Interface IP address
#   - zbp_group_id: Zabbix host group ID
#   - zbp_proxy_id: Zabbix proxy ID (optional)
#   - zb_mon_env: Environment tag (optional)
#   - zbp_platform: OS platform tag (optional)
#   - zbp_site: Site tag (optional)
#   - zbp_sla_code: SLA code tag (optional)
#   - zbp_status: Sync status (managed by playbook)
#   - zbp_last_sync: Last sync timestamp (managed by playbook)
#   - zbp_sync_hint: Sync error details (managed by playbook)
#
# Usage:
#   ansible-playbook -i inventory zabbix_sync.yml
#
# Features:
#   - Creates or updates Zabbix hosts based on NetBox inventory
#   - Supports multiple interface types with appropriate configurations
#   - Handles both devices and virtual machines
#   - Provides comprehensive error handling and status tracking
#   - Validates proxy existence and permissions
#   - Manages interface configuration (ensures single primary interface)
#   - Bidirectional status updates to NetBox custom fields
# =============================================================================

- name: Sync NetBox hosts into Zabbix (token-only)
  hosts: all
  connection: local
  gather_facts: false

  vars:
    # AWX env/cred vars
    zbx_url:   "{{ lookup('env','ZABBIX_API_URL') }}"     # https://itmonitor.../zabbix/api_jsonrpc.php
    zbx_token: "{{ lookup('env','ZABBIX_API_TOKEN') }}"
    zbx_verify: "{{ (lookup('env','ZABBIX_VERIFY') | default('false')) | bool }}"
    nb_url:    "{{ lookup('env','NETBOX_API') }}"         # https://netbox...  (base or /api)
    nb_token:  "{{ lookup('env','NETBOX_TOKEN') }}"
    nb_verify: "{{ (lookup('env','NETBOX_VERIFY') | default('true')) | bool }}"

    # Zabbix default ports by interface type
    _iface_default_ports:
      "1": "10050"   # Agent
      "2": "161"     # SNMP
      "3": "623"     # IPMI
      "4": "12345"   # JMX

  tasks:
    - name: Validate inputs present
      assert:
        that:
          - (zbx_url   | length) > 0
          - (zbx_token | length) > 0
          - (nb_url    | length) > 0
          - (nb_token  | length) > 0

    # ---------- Zabbix URL parsing (robust; no doubled api_jsonrpc.php) ----------
    - name: Parse Zabbix URL (phase 1)
      set_fact:
        zbx_scheme_https: "{{ zbx_url | regex_search('^https://') is truthy }}"
        zbx_hostport: "{{ (zbx_url | regex_replace('^https?://','')) | regex_replace('/.*$','') }}"
        zbx_path_only: "{{ '/' ~ (zbx_url | regex_replace('^https?://[^/]+','') | regex_replace('^/+','')) }}"

    - name: Parse Zabbix URL (phase 2)
      set_fact:
        zbx_api: >-
          {{
            (zbx_url | regex_replace('/+$',''))
            | regex_replace('(?i)/api_jsonrpc\\.php$','')
            ~ '/api_jsonrpc.php'
          }}
        zbx_path_clean: "{{ zbx_path_only | regex_replace('/+$','') }}"
        _auth: "{{ zbx_token }}"

    - name: Parse Zabbix URL (phase 3)
      set_fact:
        zbx_pathroot: >-
          {{
            (zbx_path_clean | regex_replace('(?i)/api_jsonrpc\\.php$',''))
            | regex_replace('^$','/')
          }}

    # # one-off sanity
    # - debug:
    #     msg: { zbx_api: "{{ zbx_api }}", zbx_hostport: "{{ zbx_hostport }}", zbx_pathroot: "{{ zbx_pathroot }}" }
    #   verbosity: 1

    # ---------- NetBox URL normalize ----------
    - name: Normalize NetBox URL (clean)
      set_fact:
        _nb_clean: "{{ nb_url | regex_replace('/+$','') }}"

    - name: Derive NetBox API root and base
      set_fact:
        nb_api_root: "{{ (_nb_clean | regex_search('/api$')) | ternary(_nb_clean, _nb_clean ~ '/api') }}"
        nb_base:     "{{ _nb_clean | regex_replace('/api$','') }}"

    # ---------- Probe CF presence for write-back ----------
    - name: Probe NetBox CF zbp_last_sync
      uri:
        url: "{{ nb_api_root }}/extras/custom-fields/?name=zbp_last_sync"
        method: GET
        headers: { Authorization: "Token {{ nb_token }}", Accept: "application/json" }
        return_content: true
        status_code: 200
        validate_certs: "{{ nb_verify }}"
      register: _probe_last_sync

    - name: Probe NetBox CF zbp_sync_hint
      uri:
        url: "{{ nb_api_root }}/extras/custom-fields/?name=zbp_sync_hint"
        method: GET
        headers: { Authorization: "Token {{ nb_token }}", Accept: "application/json" }
        return_content: true
        status_code: 200
        validate_certs: "{{ nb_verify }}"
      register: _probe_sync_hint

    - name: Set CF presence flags
      set_fact:
        _has_last_sync: "{{ (_probe_last_sync.json.results | default([]) | length) > 0 }}"
        _has_sync_hint: "{{ (_probe_sync_hint.json.results | default([]) | length) > 0 }}"

    # ---------- Normalize vars from NetBox inventory ----------
    - name: Normalize host vars from NetBox
      vars:
        cf: "{{ hostvars[inventory_hostname].custom_fields | default({}) }}"
      set_fact:
        _nb_name: "{{ inventory_hostname }}"
        _nb_visible: "{{ cf.zbp_vname | default(inventory_hostname) }}"
        _tmpl_primary_id: "{{ (cf.zbp_pri_template_name_id | string) if (cf.zbp_pri_template_name_id is defined) else '' }}"
        _tmpl_extra_ids_raw: "{{ cf.zb_extra_templates | default([]) }}"
        _iface_type: "{{ (cf.zbp_pri_template_int_id | string) if (cf.zbp_pri_template_int_id is defined) else '' }}"
        _iface_ip: "{{ cf.zbp_int_ip | default('') }}"
        _group_id: "{{ (cf.zbp_group_id | string) if (cf.zbp_group_id is defined) else '' }}"
        _tag_env: "{{ cf.zb_mon_env | default('') }}"
        _tag_os: "{{ cf.zbp_platform | default('') }}"
        _tag_site: "{{ cf.zbp_site | default('') }}"
        _tag_sla: "{{ cf.zbp_sla_code | default('') }}"
        _tag_nb_status: "{{ hostvars[inventory_hostname].status.value | default('') }}"
        _proxy_cf_raw: "{{ cf.zbp_proxy_id | default('') }}"

    - name: Coerce extra templates to list
      set_fact:
        _tmpl_extra_ids: >-
          {{
            (
              _tmpl_extra_ids_raw
              if (_tmpl_extra_ids_raw is sequence and (_tmpl_extra_ids_raw is not string))
              else ( [ _tmpl_extra_ids_raw ] if (_tmpl_extra_ids_raw | default('') | length > 0) else [] )
            )
            | map('string') | list
          }}

    - name: Build desired template id list
      set_fact:
        _desired_template_ids: >-
          {{
            ( [ _tmpl_primary_id ] if _tmpl_primary_id | length > 0 else [] )
            | union(_tmpl_extra_ids)
            | unique
          }}

    - name: Fail fast if key inputs are missing
      assert:
        that:
          - _iface_ip | length > 0
          - _iface_type | length > 0
          - _desired_template_ids | length > 0
          - _group_id | length > 0
        fail_msg: "Missing IP/interface/template/group for {{ inventory_hostname }}"

    - name: Convert IDs to ints
      set_fact:
        _group_ids_int: [ "{{ _group_id | int }}" ]
        _tmpl_ids_int: "{{ _desired_template_ids | map('int') | list }}"

    - name: Build interface details (SNMP only)
      set_fact:
        _iface_details: "{{ {'version': 2, 'community': '{$SNMP_COMMUNITY}', 'bulk': 1} if (_iface_type | int) == 2 else omit }}"

    - name: Normalize proxy id (robust)
      set_fact:
        _proxy_id_int: "{{ ((_proxy_cf_raw | string) | regex_search('\\d+') | default('0')) | int }}"

    - name: Validate proxy id in Zabbix (when provided)
      when: (_proxy_id_int | int) > 0
      uri:
        url: "{{ zbx_api }}"
        method: POST
        headers: { Content-Type: "application/json-rpc" }
        body_format: json
        validate_certs: "{{ zbx_verify }}"
        body:
          jsonrpc: "2.0"
          method: "proxy.get"
          id: 41
          auth: "{{ _auth }}"
          params:
            output: [ "proxyid", "name" ]
            proxyids: [ "{{ _proxy_id_int }}" ]
      register: _proxy_chk

    - name: Assert proxy exists or visible to the token
      when: (_proxy_id_int | int) > 0
      assert:
        that: [ (_proxy_chk.json.result | length | int) == 1 ]
        fail_msg: "Zabbix proxy id {{ _proxy_id_int }} not found or token lacks permission."

    # ---------- Zabbix host upsert + reconcile + NetBox writeback ----------
    - name: Zabbix host upsert + reconcile + NetBox writeback
      block:

        # Get host
        - name: ZBX host.get by name
          uri:
            url: "{{ zbx_api }}"
            method: POST
            headers: { Content-Type: "application/json-rpc" }
            body_format: json
            validate_certs: "{{ zbx_verify }}"
            body:
              jsonrpc: "2.0"
              method: "host.get"
              id: 1
              auth: "{{ _auth }}"
              params:
                filter: { host: [ "{{ _nb_name }}" ] }
                output: [ "hostid", "name", "host", "proxy_hostid" ]
          register: _host_get

        - name: Cache hostid if exists
          set_fact:
            _host_present: "{{ (_host_get.json.result | default([]) | length) > 0 }}"

        - name: Set hostid when present
          set_fact:
            _hostid: "{{ _host_get.json.result[0].hostid | string }}"
          when: _host_present | bool

        # Build arrays
        - name: Build Zabbix arrays
          set_fact:
            _zbx_groups_json: >-
              [{% for gid in _group_ids_int %}{"groupid":"{{ gid }}"}{% if not loop.last %},{% endif %}{% endfor %}]
            _zbx_templates_json: >-
              [{% for tid in _tmpl_ids_int %}{"templateid":"{{ tid }}"}{% if not loop.last %},{% endif %}{% endfor %}]
            _zbx_tags_json: >-
              [
                {"tag":"cmdb","value":"true"}
                {% if _tag_env|default('') %}, {"tag":"environment","value":"{{ _tag_env }}"}{% endif %}
                {% if _tag_os|default('') %}, {"tag":"os","value":"{{ _tag_os }}"}{% endif %}
                {% if _tag_site|default('') %}, {"tag":"site","value":"{{ _tag_site }}"}{% endif %}
                {% if _tag_sla|default('') %}, {"tag":"device","value":"{{ _tag_sla }}"}{% endif %}
                {% if _tag_nb_status|default('') %}, {"tag":"nb_status","value":"{{ _tag_nb_status }}"}{% endif %}
              ]

        - name: Derive desired Zabbix status from NetBox status (active=enabled, else disabled)
          set_fact:
            _nb_status_norm: "{{ _tag_nb_status | default('', true) | string | lower }}"

        - name: Set Zabbix desired status
          set_fact:
            _zbx_desired_status: "{{ 0 if _nb_status_norm == 'active' else 1 }}"

        # Create or update host (replace groups & templates). No Jinja blocks inside mappings!
        - name: ZBX host.create (if absent)
          when: _hostid is not defined
          uri:
            url: "{{ zbx_api }}"
            method: POST
            headers: { Content-Type: "application/json-rpc" }
            body_format: json
            validate_certs: "{{ zbx_verify }}"
            body:
              jsonrpc: "2.0"
              method: "host.create"
              id: 2
              auth: "{{ _auth }}"
              params:
                host: "{{ _nb_name }}"
                name: "{{ _nb_visible }}"
                groups: "{{ _zbx_groups_json | from_yaml }}"
                templates: "{{ _zbx_templates_json | from_yaml }}"
                proxy_hostid: "{{ ((_proxy_id_int | int) > 0) | ternary((_proxy_id_int | int) | string, '0') }}"
                tags: "{{ _zbx_tags_json | from_yaml }}"
                status: "{{ _zbx_desired_status | default(1) }}"
                interfaces:
                  - type: "{{ _iface_type | int }}"
                    main: 1
                    useip: 1
                    ip: "{{ _iface_ip }}"
                    dns: ""
                    port: "{{ _iface_default_ports[_iface_type] | default('10050') }}"
                    details: "{{ _iface_details | default(omit) }}"
          register: _host_create

        - name: Cache hostid from create
          when: _hostid is not defined
          set_fact:
            _hostid: "{{ _host_create.json.result.hostids[0] }}"

        - name: ZBX host.update (if present)
          when: _hostid is defined
          uri:
            url: "{{ zbx_api }}"
            method: POST
            headers: { Content-Type: "application/json-rpc" }
            body_format: json
            validate_certs: "{{ zbx_verify }}"
            body:
              jsonrpc: "2.0"
              method: "host.update"
              id: 3
              auth: "{{ _auth }}"
              params:
                hostid: "{{ _hostid }}"
                status: "{{ _zbx_desired_status | default(1) }}"
                host: "{{ _nb_name }}"
                name: "{{ _nb_visible }}"
                groups: "{{ _zbx_groups_json | from_yaml }}"
                templates: "{{ _zbx_templates_json | from_yaml }}"
                proxy_hostid: "{{ ((_proxy_id_int | int) > 0) | ternary((_proxy_id_int | int) | string, '0') }}"
                tags: "{{ _zbx_tags_json | from_yaml }}"

        # Ensure only one primary interface with correct type/IP
        - name: Fetch interfaces
          uri:
            url: "{{ zbx_api }}"
            method: POST
            headers: { Content-Type: "application/json-rpc" }
            body_format: json
            return_content: true
            validate_certs: "{{ zbx_verify }}"
            body:
              jsonrpc: "2.0"
              method: "host.get"
              id: 5
              auth: "{{ _auth }}"
              params:
                output: [ "hostid" ]
                selectTags: [ "tag", "value" ]
                selectInterfaces: [ "interfaceid", "type", "ip", "main" ]
                hostids: [ "{{ _hostid }}" ]
          register: _hostget2

        - name: Current host facts
          set_fact:
            _cur_tags: "{{ _hostget2.json.result[0].tags | default([]) }}"
            _cur_ifaces: "{{ _hostget2.json.result[0].interfaces | default([]) }}"

        - name: Ensure primary interface matches desired
          vars:
            _match: "{{ _cur_ifaces | selectattr('main','equalto','1') | selectattr('type','equalto', (_iface_type | int)) | selectattr('ip','equalto', _iface_ip) | list }}"
          block:
            - name: Delete all existing interfaces if they don’t match
              when: _match | length == 0 and _cur_ifaces | length > 0
              uri:
                url: "{{ zbx_api }}"
                method: POST
                headers: { Content-Type: "application/json-rpc" }
                body_format: json
                validate_certs: "{{ zbx_verify }}"
                body:
                  jsonrpc: "2.0"
                  method: "hostinterface.delete"
                  id: 6
                  auth: "{{ _auth }}"
                  params: "{{ _cur_ifaces | map(attribute='interfaceid') | list }}"

            - name: Create desired primary interface (if needed)
              when: _match | length == 0
              uri:
                url: "{{ zbx_api }}"
                method: POST
                headers: { Content-Type: "application/json-rpc" }
                body_format: json
                validate_certs: "{{ zbx_verify }}"
                body:
                  jsonrpc: "2.0"
                  method: "hostinterface.create"
                  id: 7
                  auth: "{{ _auth }}"
                  params:
                    hostid: "{{ _hostid }}"
                    main: 1
                    type: "{{ _iface_type | int }}"
                    useip: 1
                    ip: "{{ _iface_ip }}"
                    dns: ""
                    port: "{{ _iface_default_ports[_iface_type] | default('10050') }}"
                    details: "{{ _iface_details | default(omit) }}"

        # Success write-back
        - name: Build success payload
          set_fact:
            _cf_success: >-
              {{
                {'zbp_status':'synced'}
                | combine( (_has_last_sync|bool) | ternary({'zbp_last_sync': lookup('pipe','date -Is')}, {}), recursive=True)
                | combine( (_has_sync_hint|bool) | ternary({'zbp_sync_hint': ''}, {}),                     recursive=True)
              }}

        - name: Success writeback → NetBox (Device)
          when: not (hostvars[inventory_hostname].is_virtual | default(false))
          delegate_to: localhost
          netbox.netbox.netbox_device:
            netbox_url: "{{ nb_base }}"
            netbox_token: "{{ nb_token }}"
            validate_certs: "{{ nb_verify }}"
            data:
              name: "{{ _nb_name }}"
              custom_fields: "{{ _cf_success }}"
            state: present

        - name: Success writeback → NetBox (VM)
          when: hostvars[inventory_hostname].is_virtual | default(false)
          delegate_to: localhost
          netbox.netbox.netbox_virtual_machine:
            netbox_url: "{{ nb_base }}"
            netbox_token: "{{ nb_token }}"
            validate_certs: "{{ nb_verify }}"
            data:
              name: "{{ _nb_name }}"
              custom_fields: "{{ _cf_success }}"
            state: present

      rescue:
        - name: Capture error
          set_fact:
            _sync_err: "{{ (ansible_failed_result.msg | default(ansible_failed_task.name | default('Zabbix sync failed'))) }}"

        - name: Build failure payload
          set_fact:
            _cf_fail: >-
              {{
                {'zbp_status':'not_synced'}
                | combine( (_has_sync_hint|bool) | ternary({'zbp_sync_hint': _sync_err}, {}), recursive=True)
              }}

        - name: Failure writeback → NetBox (Device)
          when: not (hostvars[inventory_hostname].is_virtual | default(false))
          delegate_to: localhost
          netbox.netbox.netbox_device:
            netbox_url: "{{ nb_base }}"
            netbox_token: "{{ nb_token }}"
            validate_certs: "{{ nb_verify }}"
            data:
              name: "{{ _nb_name }}"
              custom_fields: "{{ _cf_fail }}"
            state: present

        - name: Failure writeback → NetBox (VM)
          when: hostvars[inventory_hostname].is_virtual | default(false)
          delegate_to: localhost
          netbox.netbox.netbox_virtual_machine:
            netbox_url: "{{ nb_base }}"
            netbox_token: "{{ nb_token }}"
            validate_certs: "{{ nb_verify }}"
            data:
              name: "{{ _nb_name }}"
              custom_fields: "{{ _cf_fail }}"
            state: present
